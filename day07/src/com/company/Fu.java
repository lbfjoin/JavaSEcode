package com.company;

/**
 * @author lbf
 * @date 2020/5/31 14:38
 * 继承后的变化：一.成员变量：1.不重名情况：如果子类父类中出现不重名的成员变量，访问是没有影响的
 *                         2.重名情况：有影响，new子类时候调用的是子类的成员变量，想要调用父类的，要用super关键字，就像本类使用this一样.父类中成员变量私有，我们可以通过get,set方法访问父类的成员变量
 *             二.成员方法：1.不重名情况：没影响，对象在调用方法时，会在子类中查找有没有对应的方法，没有就回去父类中找相应的方法去执行
 *                        2.重名(重写Override）情况：子类出现了与父类一模一样的方法（返回值类型，方法名，参数列表都相同）---》会出现覆盖效果（也叫复写）----》声明不变重新实现
 *                           应用-----子类个性化定制自己的方法  （注：调用父类的成员方法，super.成员方法） （子覆盖父，保证权限大于等于父类）
 *             三.构造方法: 构造方法的名字和类名一致，所以子类无法继承父类构造方法
 *                         构造方法的作用是初始化成员变量，所以子类初始化的过程中必须先执行父类的初始化动作，子类的构造方法默认有一个super()，表示调用父类的构造方法，父类成员变量初始化后才可以给子类使用
 *                         super:代表父类的存储空间标识（父类的引用）  格式：super.成员方法（）【父类的】；  super.成员变量【父类的】
 *                         this:调用当前类的对象的引用（谁调用就代表谁）  格式：this.成员方法（）【本类的】；  this.成员变量【本类的】
 *                         super()和this()： // 1.子类中每个构造方法中均有super（）,用来调用父类空参构造
 *                                         //2.手动调用父类的构造会覆盖默认的super()
 *                                        //3.super()、this()必须在构造方法的第一行，所以两者不能同时出现
 */
public class Fu {
    int num = 5;
    public void show_Fu(){
        System.out.println("Fu类的show_Fu方法执行");
    }
    public void show(){
        System.out.println("Fu类的show方法执行");
    }
}
